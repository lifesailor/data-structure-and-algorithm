## Chapter 2. 정렬

정렬은 객체들이 나열된 순서를 어떤 논리적인 순서에 맞게 바꾸는 작업이다. 모든 컴퓨팅 시스템은 사용자나 시스템 자체적으로 정렬을 활용할 수 있도록 정렬 알고리즘의 구현을 제공하고 있다. 시스템에서 제공하는 정렬 기능을 사용하더라도, 아래와 같은 세 가지 이유로 정렬 알고리즘 학습이 필요하다.

- 정렬 알고리즘 분석은 이 책에서 보여질 서로 다른 알고리즘 간의 비교 방법을 상세하게 소개하는 역할을 한다.
- 정렬 알고리즘에 적용한 테크닉은 다른 문제에서도 비슷하게 활용될 수 있다.
- 어떤 문제를 풀 때 정렬부터 시작해야 하는 경우가 자주 있다.

이러한 실용적인 이유 말고도 정렬 알고리즘은 우아하고 클래식하며 효과적이라는 점도 있다.

<br/>

## 1. 기초적인 정렬 방법

**선택 정렬**

- 선택 정렬(Selection Sort)은 가장 작은 항목을 찾고 이와 뒤바꿈하는 정렬 알고리즘이다. 
- 선택 정렬은 길이 N의 배열에 대해 ~$\frac{N^{2}}{2}​$ 번의 비교와 $N​$ 번의 교환을 수행한다,

<br/>

**삽입 정렬**

- 삽입 정렬(Insertion Sort)는 항목을 삽입할 공간을 만들기 위해 삽입할 항목보다 큰 항목을 오른쪽으로 밀어서 이동한다. 그리고 확보된 빈 공간에 항목을 삽입한다.
- 선택 정렬과 달리 삽입 정렬의 실행 시간은 초기 입력 배열에서 항목들이 정렬된 상태에 의존적이다. 예를 들어 배열이 매우 크고 항목이 이미 정렬된 상태라면 무작위 순서 또는 역순 배열보다 훨씬 더 빠르게 정렬한다.
- 삽입 정렬은 중복 없는 키를 가진 무작위로 정렬된 크기 $N$ 인 배열에 대해 평균 ~$\frac{N^{2}}{4}$ 비교와 ~$\frac{N^2}{4}$ 번의 교환을 수행한다. 최악 조건에서는 ~$\frac{N^{2}}{2}$ 번의 비교와  ~$\frac{N^{2}}{2}$ 번의 교환을 수행하고 최적 조건에서는 $N-1$ 번의 비교와 0번의 교환을 수행한다.

<br/>

**셸 정렬**

- 셸 정렬(Shell 정렬)은 삽입 정렬의 확장 버전으로 서로 멀리 떨어진 항목 간에도 교환이 일어날 수 있게 함으로써 삽입 정렬이 빠르게 처리할 수 있는 부분적으로 정렬된 배열을 만든다.
- 기본적인 아이디어는 매 h번째 항목들 간에 순서를 따질 때 정렬된 상태가 되도록 배열을 재정리하는 것이다. 이렇게 부분적으로 정렬된 배열을 'h-정렬' 되었다라고 한다.
- 셸 정렬은 선택 정렬이나 삽입 정렬에 대비해 큰 크기의 배열에서도 유용하다. 그리고 임의의 순서로 정렬된 배열에 대해서도 좋은 성능을 보여준다. 셸 정렬의 성능 특징을 분석하려면 이 책의 범위를 벗어나는 수학적인 논증이 필요하다. shell_sort의 최악 조건 비교 횟수는 $N^{3/2}$ 에 비례한다고 알려져 있다.

<br/>

## 2. 병합 정렬

- 병합 정렬은 두 개의 정렬된 배열을 하나의 큰 배열로 합치는 작업이다. 이 작업은 재귀적 방법으로 쉽게 구현된다. 즉, 배열을 정렬할 때, 그것을 반으로 나누어 각각의 절반에 대해서 재귀적으로 정렬을 수행하고 다시, 재귀적으로 정렬 결과를 병합한다.  병합 정렬의 가장 큰 장점은 크기가 $N$ 인 배열을 정렬하는 시간이 $N log N$ 에 비례한다는 것이다. 대신 $N$ 에 비례하는 추가적인 메모리 공간을 소요한다는 것이 가장 큰 단점이다.
- 하향식 병합 정렬은 크기 N인 배열을 정렬할 때 ~$1/2 NlogN \dots NlogN$ 사이의 횟수로 비교 연산을 수행한다. 
  - C(N) >= C(N/2) + C(N/2) + [N/2]에서 $N=2^n​$ 을 대입하고 점화식을 푼다.
  - 하향식 병합 정렬은 크기 N인 배열을 정렬할 때 최대 6NlogN 번의 배열 접근을 한다. (복제에 2N번, 이동에 2N번, 비교에 2N번)
  - 작은 부분 배열에 삽입 정렬 이용하기, 배열이 이미 정렬된 상태인지 확인하기, 임시 작업 배열로 복제 제거 등으로 성능을 향상할 수 있다.

<p align="center">
    <img src="https://github.com/lifesailor/data-structure-and-algorithm/blob/master/images/chapter2/top_down.jpeg?raw=true" style: width=400px; height=600px;>
</p>

- 상향식 병합 정렬은 작은 부분 배열들을 한 번의 순회로 병합할 수 있도록 병합 순서를 조정하는 것이다. 그리고 다음 번 순회에서 다시 좀 더 커진 부분 배열들을 짝지어서 병합한다.
  - 마찬가지로 상향식 벙합 정렬은 ~$1/2 NlogN \dots NlogN$ 사이의 횟수로 비교 연산을 수행하고, 크기 N인 배열을 정렬 할 때 최대 6NlogN 번의 배열 접근을 한다. 

<p align="center">
    <img src="https://github.com/lifesailor/data-structure-and-algorithm/blob/master/images/chapter2/bottom_up.jpeg?raw=true" style: width=600px; height=400px;>
</p>

- 비교 기반 알고리즘이라면 N개 항목을 정렬할 때 $log(N!) ~ NlogN$ 보다 적은 비교 횟수를 사용해서는 정렬을 완료할 수 없다. (p279)
  - 적어도 N개의 항목을 정렬하려면 비교연산 트리가 최소한 N! 만큼의 잎 노드를 가져야 한다.
  - 스털링 근사 = $logN! = log1 + log2 + log3 + \dots + logN = $ ~ $N log N$
  - 따라서, 병합 정렬은 점근적으로 볼 때, 존재할 수 있는 최적 비교 기반 정렬 알고리즘이다.
- 병합 정렬이 최적 속성이 연산 복잡도의 끝이 아니다. 이 부분을 절대적인 것으로 오해하여 실제 응용 환경에 맞추어 적용할 수 있는 다른 더 나은 방법을 찾아사보기를 중단해서는 안 된다. 이 절에서 얘기된 이론은 몇 가지 한계를 갖는다. 다음은 그 한계의 예다.
  - 공간 활용에 있어서는 병합 정렬이 최적이라고 할 수없다.
  - 가정한 최악 조건이 실제 응용 상황과 다를 수 있다.
  - 비교 연산 외 다른 연산이 더 중요할 수 있다.
  - 비교 연산을 전혀 사용하지 않고도 정렬할 수 있는 데이터가 있을 수 있다.

<br/>

## 3. 퀵 정렬(p287)

- 퀵 정렬 알고리즘은 추가적인 메모리를 사용하지 않고 입력 배열의 메모리 안에서 즉석으로 정렬되고 평균적으로 크기 N인 배열을 정렬하는데 NlogN에 비례하는 시간을 소요한다. 이러한 특성은 정렬 알고리즘이 가져야 할 이상적인 것들이다. 더욱이 퀵 정렬은 다른 정렬 알고리즘과 비교해 가장 짧은 내부 루프를 가진다. 즉, 이론적으로뿐만 아니라 실제 응용 환경에서도 좋은 성능을 보인다.

- 퀵 정렬은 분할 정복 방식으로 정렬을 수행한다. 병합 정렬에서는 배열을 두 개의 부분 배열로 나누어 각각을 정렬한 다음 정렬된 부분 배열들을 다시 전체 배열로 합치며 정렬한다. 반면에 퀵 정렬에서는 두 배열을 나뉘되, 각각의 배열이 정렬된다면 전체 배열도 이미 정렬된 상태가 되도록 나눈다. 병합 정렬에서는 전체 배열에 대한 작업을 하기 전에 두 개의 재귀 호출을 수행했지만 퀵 정렬에서는 전체 배열에 대한 작업을 수행한 이후에 2개의 재귀 호출을 한다. 병합 정렬에서는 배열이 절반으로 나누어졌찌만 퀵 정렬에서는 배열의 내용에 따라 분할되는 위치가 달라진다.

- 이 방법의 핵심은 다음의 세 가지 조건을 유지하는 배열의 재배열 및 분할 과정에 있다.
  - 항목 a[j]의 j는 전체 배열 상에서 최종적으로 결정된 정렬 위치이다,
  - a[lo]에서 a[j-1]에 이르는 항목 중에 a[j]보다 큰 항목은 없다.
  - a[j+1]에서 a[hi]에 이르는 항목 중에 a[j]보다 작은 항목은 없다.

<p align="center">
    <img src="https://github.com/lifesailor/data-structure-and-algorithm/blob/master/images/chapter2/quick-sort.jpeg?raw=true" style: width=600px; height=400px;>
</p>

- 퀵 정렬의 내부 루프는 인덱스를 증가시키면서 어떤 고정된 값과 배열 항목의 값을 비교한다. 이러한 단순함이 퀵 정렬을 빠르게 하는 요인이다. 병합 정렬이나 셸 정렬이 전형적으로 더 느린 이유는 내부 루프에서 데이터 이동까지 하기 때문이다.
- 퀵 정렬을 빠르게 하는 두 번째 요인은 적은 수의 비교 연산을 하기 때문이다. 퀵 정렬의 효율은 종국적으로 배열을 얼마나 잘 분할 하느냐에 달려 있다. 그리고 이 부분은 어떤 항목을 분할 기준 항목으로 선택하느냐에 의해 결정된다. 분할이 균형 있게 이루어지지 않을 경우 극단적으로 비효율적이 될 수 있다. 입력 배열을 정렬하기 전에 무작위로 섞는 이유는 이러한 상황을 피하기 위해서다.

<br/>

### 3중 분할을 이용하는 퀵 정렬

- 중복 키가 많은 입력에 대해서는 퀵 정렬 보다 훨씬 더 효율적이다. 같은 키들로 이루어진 배열에 대해서는 재귀 호출을 할 필요가 없다. 
- 왼쪽에서 오른쪽으로 한 번 배열 순회를 한다. 이 때, a[lo .. lt-1] < v 와 a[gt+1 .. hi] > v 그리고 a[lt .. i-1] == v가 되도록 포인터 lt와 gt를 관리한다.
  - a[i]가 v보다 작다: a[lt]와 a[i]를 교환하고 lt와 i를 증가시킨다.
  - a[i]가 v보다 크다: a[i]와 a[gt]를 서로 교환하고 gt를 감소시킨다.
  - a[i]와 v가 같다. i를 증가시킨다.

<p align="center">
    <img src="https://github.com/lifesailor/data-structure-and-algorithm/blob/master/images/chapter2/quick3-sort.jpeg?raw=true" style: width=600px; height=400px;>
</p>

<br/>

## 4. 우선순위 큐

키 값 순서대로 정렬된 항목을 처리해야 하는 응용 상황이 많지만 꼭 전체가 정렬되어야 하거나 한 번에 정렬이 완료되어야 하는 것이 아니다. 부분적으로 항목 중에서 가장 큰 키를 찾아서 처리한 후, 항목을 좀 더 모으고 그 상황에서 다시 큰 키를 찾아서 처리해나가는 점진적인 응용 상도 자주 있따. 예를 들어 여러 개의 어플리케이션을 동시에 구동할 수 있는 컴퓨터나 스마트폰이 있다고 한다. 이렇게 동시에 구동되는 효과는 이벤트에 우선순위를 부여하고, 가장 높은 우선순위 이벤트에 연결된 어플리케이션에 처리 기회를 주는 방식으로 계속해서 수행함으로써 구현된다.

<br/>

이러한 응용 상황을 지원하기 위한 데이터 타입이라면 두 가지 연산, **최대값 항목 삭제** 그리고 **새로운 항목 추가**를 지원해야 한다. 이러한 데이터 타입을 우선순위 큐라 한다. 우선순위 큐의 사용법은 기본적인. 큐나 스택의 사용 방법과 비슷하다. 하지만 우선순위에 따른 동작을 효율적으로 구현하는 것은 좀 더 어렵다.

<br/>

**이진 힙** 데이터 구조에 기반한 전통적인 우선순위 큐에 대해서 상세히 살펴본다. 이진 힙 데이터 구조는 배열에 항목들을 저장하되 항목의 삽입 작업과 최대값 항목 삭제 작업이 로그 시간 안에 효율적으로 될 수 있도록 항목의 저장 순서를 특별하게 고안한 것이다.

<br/>

### 1. 힙

이진 힙은 우선순위 큐의 기본 동작들을 효율적으로 할 수 있게 해주는 데이터 구조이다. 이진 힙에서는 키들을 배열에 저장할 때 각각의 키가 특정한 두 위치에 있는 다른 키들보다 크거나 같아야 하는 것이 보증되는 형태로 저장된다. 각각의 키는 차례대로 자신에게 추가적으로 연결된 두 키보다 크거나 같아야 한다. 이진 트리 구조에서 각 키의 간선을 따라 더 작은 키 두 개가 연결된 것을 떠올리면 이러한 순서가 쉽게 가시적으로 이해된다.

- 이진 트리에서 각 노드의 두 자식 노드의 키 값이 부모 노드의 키 값보다 작으면 그 이진 트리는 힙 정렬되었다고 한다.
- 이진 힙은 힙 정렬된 완전 이진 트리 노드들이 그 트리 레벨 순서대로 배열에 나열된 것이다. (단, 배열의 첫 항목은 이용하지 않는다.)
- 크기 N인 완전 이진 트리의 높이는 logN이다. 

<br/>

어떤 노드의 우선순위가 증가되었을 때, **힙을 거슬러 올라가면서 힙의 순서(swim)**를 바로 잡아야 한다. 그리고 어떤 노드의 우선순위가 낮아졌을 때는 힙을 내려가면서 **힙을 내려가면서 힙의 우선순위(sink)**를 바로 잡아야 한다. 먼저, 이 두 가지 보조 작업을 어떻게 구현할 지 알아본 다음, 삽입 작업과 최대 항목 삭제 작업에 어떻게 활요될 수 있는지 살펴본다.

<br/>

**swim**

만약 어떤 노드가 부모 노드보다 커지면서 힙의 순서가 어긋난다면 그 노드를 부모 노드와 교환하여 합을 복구할 수 있다. 교환 휑는 그 노드가 자식 노드보다 크기가 큰 상태가 된다. 하지만 그렇게 교환한 후에도 새로운 부모와의 관계에서 자식 노드가 더 클 수 있다. 이 때는 힙을 올라가면서 교환을 반복해나간다.

<br/>

**sink**

만약 어떤 노드가 두 자식 노드들 중 어느 하나보다 작아서 힙 순서가 위반된다면 그 노드를 자식 노드들 중에서 큰 노드와 교환함으로써 순서를 바로잡을 수 있다. 이렇게 교환하고 나서 자식 노드 수준에서 순서 위반 상태가 발생할 수 있다. 이 경우 마찬가지 방법으로 순서를 바로잡는다. 이 방법을 순서가 올바를 때까지 또는 힙의 바닥에 다다를 때까지 힙을 반복하며 내려간다.

<br/>

sink()와 swim() 작업은 효율적인 우선순위 큐 API를 구현하는 기반이 된다. 다음은 우선순위 큐 API에 대한 설명 다이어 그램이다.

- 삽입: 배열 끝부분에 새로운 키를 추가하고 힙의 크기를 늘려간다. 그 다음 힙을 거슬러 올라가면서 힙 순서를 바로잡는다.
- 최대 항목 삭제: 힙의 꼭대기에서 가장 큰 항목을 꺼내고, 힙의 바닥에 있는 항목을 힙의 꼭대기로 옮긴다. 힙의 크기를 줄인다음 힙을 내려오면서 힙 순서를 바로잡는다.

<br/>

### 2. 힙 정렬 

힙정렬은 두 단계 힙 구성과 정렬 취합으로 나뉜다. 힙 구성은 배열을 힙으로서 재배치하는 것이고 정렬 취합은 힙에서 내림차순으로 항목을 꺼내어 정렬된 결과를 만드는 것이다.

<br/>

**힙 구성** 

N 개의 항목이 주어졌을 때 NlogNㅇ 비례하는 시간 안에 작업을 완료할 수 있다. 배열을 왼쪽에서 오른쪽으로 순회하면서 swim()을 이요해 순회 중인 항목의 왼쪽편이 힙 순서를 만족하는 완전 트리인지 검사하고 복구해 나간다. 

**정렬 취합**

힙에 남아 있는 항목들 중에서 가장 큰 항목을 꺼내어 삭제하면서 힙이 줄어들면서 비어 있게 된 배열 위치에 집어넣는다. 

<br/>

## 5. 전체 요약

<p align="center">
    <img src="https://github.com/lifesailor/data-structure-and-algorithm/blob/master/images/chapter2/sort.jpeg?raw=true" style: width=600px; height=400px;>
</p>

